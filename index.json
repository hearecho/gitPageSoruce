[{"categories":null,"contents":"","date":"Jun 24","permalink":"https://hearecho.github.io/projects/spider/","tags":null,"title":"Spider"},{"categories":null,"contents":"","date":"Jun 24","permalink":"https://hearecho.github.io/projects/web/","tags":null,"title":"Go-Web-Template"},{"categories":["论文阅读","算法"],"contents":"论文简介 《A new DAG based dynamic task scheduling algorithm (DYTAS) for multiprocessor systems》\n论文提出一种基于有向无环图（DAG）的动态任务调度算法。关注点主要是通过多处理系统，进行并行处理任务。主要关注点在于多处理器系统，并行。在多处理器系统中实现高性能是调度并行任务的关键因素。而动态任务调度的目标是将并行任务映射到多处理器上，并对执行顺序进行排序。\n本文旨在建立一个基于DAGs的动态调度模型。在该模型中，一个被分配的处理器称为中心调度器，负责动态地调度任务。在提出的动态调度模型的基础上，提出了一种新的动态调度算法。该算法在仿真环境下进行了实验，实验结果表明，所提出的调度算法是一种有效的动态调度算法，具有更好的性能。\n 我们常说的对于有向无环图最短执行时间的拓扑排序算法是在单处理器上进行运行的，任务是按照排序好的序列进行执行。\n DAG介绍 有向无环图(DAG) G = (V, E)，其中V是v个节点/顶点的集合，E是e个有向边的集合。边缘的源节点称为父节点，而汇聚节点称为子节点。没有父节点的节点称为入口节点，没有子节点的节点称为出口节点。\n相关工作 很多动态调度算法是为了支持实时系统进行设计的。实时系统是指系统的性能不仅取决与逻辑计算结果，而且还取决于结果产生的时间。\n调度算法分为静态调度算法和动态调度算法。\n 静态调度算法：任务的分配是离线进行的，即在实时任务正式在处理机上调度执行前，先把任务在处理机上的分配和调度时间安排好,在任务正式开始执行后按照预先的调度方案执行。这种调度方法主要用于周期任务的调度，它的优点在于能够预先安排好调动，减少任务调度过程中的开销;而缺点在于缺乏灵活性，在实际的调度中不能够及时地根据系统资源和任务的执行情况进行及时的调整。 动态调度算法：在实时系统中，很多任务并非都以周期方式在处理机上进行调度，更多任务，特别是非周期任务都是随机到达系统并动态调度执行的。在动态调度方法中，任务的分派和可调度性测试都是在系统运行时在线进行的。这种情况下，可调度性测试实际上变成了一种接受测试(acceptance test), 测试动态到达任务的截止期是否会被保证，如果无法保证任务的截止期，任务将被拒绝调度。可以看出，动态调度与静态调度相比有更好的灵活性，然后由于可调度性测试需要在线进行，它的调度算法的复杂度不能太高，并且由 于无法保证是否可以被调度，算法的可预测性(predictability)很差。也就是说动态调度算法主要算法是在线测试预估任务是否可以满足。  系统模型 负载模型 并行任务采用DAG建模。非实时DAG[7]定义为：G=（V，E），其中V是一组v个节点，E是一组w条有向边。DAG中的一个节点表示一个任务，而这个任务又是一组指令，这些指令必须在同一个处理器中顺序执行而不被抢占。节点ni的权重称为计算成本，用w（vi）表示。DAG中的边，每个边用（vi，vj）表示，对应于节点之间的通信消息和优先约束。边的权重称为边的通信开销，用c（vi，vj）表示。\n我们的系统看作有一组处理器组成，P={P1，P2，P3，…Pm}，其中Pi表示具有本地存储器的处理器。处理器之间是也是具有通信开销的。\n调度器模型 如下图所示，描述的是一个同构环境中一个新的非实时调度器模型。当所有并行任务到达一个被指定的中央调度器时，他将进入一个称为初始任务队列（ITQ）的队列，等待被调度；除了ITQ之外，还管理着两个队列：调度任务队列（DTQ）和完成任务队列（CTQ）。封装在调度器中的调度算法开始与ITQ一起工作。中央调度器负责调度DTQ中的每个就绪任务。一旦调度算法启动，所有的任务都会根据其依赖的任务进行安排。在安排任务之后，调度器将任务安排到单个处理器任务队列（PTQ）。处理器将在自己的PTQ中通过同时检查CTQ中的依赖任务结果来完成任务。如果CTQ没有利用其相关任务的结果，则PTQi应指向下一个PTQi+1、PTQi+2、…PTQn、PTQ1、…PTQi-1以确定合适的任务，并将该任务迁移到PTQi。在PTQi变空之前，调度算法应停止工作。Processor Status Window（PSW）显示处于运行状态和空闲状态的每个处理器的状态。\n动态调度算法-DYTAS 基于上述的调度模型，提出了一种新的动态调度算法。ITQ中的任务是通过依赖关系进行调度的。该算法首先对于ITQ中的前面的任务进行调度，并将其映射到处理器上。而在静态调度算法中，由于DAG的数据是预先知道的，所以任务是按一定的优先级排序的。但是，本文提出的动态调度算法不同于静态调度算法，它在运行时迁移任务。\nDYTAS算法的核心是处理器的选择策略，也就是对于任务的迁徙。主要取决于如何选择任务映射到的处理器，即使任务被调度得更早。\n当从PTQ集合中中选择处理器来执行特定任务时，必须考虑两个时间索引：\n 处理器Pi的最早空闲时间 处理器Pi上任务vi的最早开始时间。  在所提出的调度模型中，ITQ中的并行任务和就绪任务都在处理器的PTQ中。即使ITQ和DTQ位于中央调度器上，实际执行映射任务的处理器也与调度器分离并放置在PTQi处。同时，调度过程和执行过程是并行的。因此，调度器和工作处理器之间是同步的。\n未完！！\n每日一题 你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： \u0026lsquo;0\u0026rsquo;, \u0026lsquo;1\u0026rsquo;, \u0026lsquo;2\u0026rsquo;, \u0026lsquo;3\u0026rsquo;, \u0026lsquo;4\u0026rsquo;, \u0026lsquo;5\u0026rsquo;, \u0026lsquo;6\u0026rsquo;, \u0026lsquo;7\u0026rsquo;, \u0026lsquo;8\u0026rsquo;, \u0026lsquo;9\u0026rsquo; 。每个拨轮可以自由旋转：例如把 \u0026lsquo;9\u0026rsquo; 变为 \u0026lsquo;0\u0026rsquo;，\u0026lsquo;0\u0026rsquo; 变为 \u0026lsquo;9\u0026rsquo; 。每次旋转都只能旋转一个拨轮的一位数字。\n锁的初始数字为 \u0026lsquo;0000\u0026rsquo; ，一个代表四个拨轮的数字的字符串。\n列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。\n字符串 target 代表可以解锁的数字，你需要给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回 -1 。\n 题目中问的是最小拨动次数，对应图中两者之间的最短路径，所以这种类型的题大多都广度优先搜索，因为有四个位置，并且每次拨动都有两种选择。而对于已经搜索过的图将不会再次搜索。对于每次的字符串他的下一个变化的字符串有八个。\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  func openLock(deadends []string, target string) int { step := -1 queue := make([]string, 0) visited := make(map[string]bool, 0) for i := 0; i \u0026lt; len(deadends); i++ { visited[deadends[i]] = true } if _, ok := visited[\u0026#34;0000\u0026#34;]; ok { return -1 } queue = append(queue, \u0026#34;0000\u0026#34;) for len(queue) != 0 { size := len(queue) //没过一层就要步数加1，刚开始的0000不算在内 \tstep++ for i := 0; i \u0026lt; size; i++ { cur := queue[i] //当前字符串与目标字符串相同则return \tif cur == target { return step } //取出现在的队头字符串 \tfor j := 0; j \u0026lt; len(cur); j++ { //每个字符的变化,之后再将 \tchangenum, _ := strconv.Atoi(cur[j : j+1]) nstr1, nstr2 := \u0026#34;\u0026#34;, \u0026#34;\u0026#34; if changenum == 9 { nstr1 = cur[:j] + strconv.Itoa(0) + cur[j+1:] } else { nstr1 = cur[:j] + strconv.Itoa(changenum+1) + cur[j+1:] } if changenum == 0 { nstr2 = cur[:j] + strconv.Itoa(9) + cur[j+1:] } else { nstr2 = cur[:j] + strconv.Itoa(changenum-1) + cur[j+1:] } if _, ok := visited[nstr1]; !ok { queue = append(queue, nstr1) visited[nstr1] = true } if _, ok := visited[nstr2]; !ok { queue = append(queue, nstr2) visited[nstr2] = true } } } queue = queue[size:] } return -1 }   ","date":"Jun 25","permalink":"https://hearecho.github.io/post/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-dag/","tags":["论文阅读","DAG","算法"],"title":"论文阅读 DAG"},{"categories":["blog"],"contents":"添加谷歌收录 添加谷歌收录的方式主要有四种方式：\n Google Analytics HTML file HTML tag Google Tag Manager Domain name provider  最简单的方式就是使用HTML TAG直接在模板head标签里面加上网站给出的验证标签即可。\ngoogle 分析 添加谷歌分析，可以获知自己网站的各项数据。同时也可以用于上述使得网站被谷歌收录。\n注册Google 分析   打开Google Analytics官网注册账户并添加自己的网站域名 打开主页，添加数据流，之后记录衡量ID。   修改配置文件 在config.toml中新建googleAnalytics参数并设置成自己的衡量ID\n1  googleAnalytics = \u0026#34;xx-xxxxxxxxx-x\u0026#34; # Enable Google Analytics by entering your tracking id   新建模板 在Hugo站点根目录下新建模板文件(./layouts/_internal/google_analytics_async.html)并添加如下代码.\n1 2 3 4 5 6 7 8 9  \u0026lt;!-- Global Site Tag (gtag.js) - Google Analytics --\u0026gt; \u0026lt;script async src=\u0026#34;https://www.googletagmanager.com/gtag/js?id={{ .Site.GoogleAnalytics }}\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag(\u0026#39;js\u0026#39;, new Date()); gtag(\u0026#39;config\u0026#39;, \u0026#39;{{ .Site.GoogleAnalytics }}\u0026#39;); \u0026lt;/script\u0026gt;   引用模板 在baseof.html基础模板文件中的head标签尾部添加如下代码, 这样站点发布到非Hugo Server后就会自动引用Google Analytics模板.或者也可以将上述的模板内容直接粘贴复制到baseof.html相应的位置。\n1 2 3 4 5  \u0026lt;head\u0026gt; {{- if not .Site.IsServer }} {{ template \u0026#34;_internal/google_analytics_async.html\u0026#34; . }} {{- end }} \u0026lt;/head\u0026gt;   每日一题 下一个排列 实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。必须 原地 修改，只允许使用额外常数空间。\n 目的是寻求按照字典序来说，下一个排列，当然可以找到全部排列，但是不太靠谱。我们可以自己通过该排列的顺序，找到下一个排列。\n例如：\n[1,2,3]\n[1,3,2]\n[2,1,3]\n[2,3,1]\n[3,1,2]\n[3,2,1]\n所以我们的目标是将左边一个较小的数和右边的一个较大的数进行交换，如此下一个排列才会更大，同时由于不能打太多。同时我们要让这个「较小数」尽量靠右，而「较大数」尽可能小。当交换完成后，「较大数」右边的数需要按照升序重新排列。这样可以在保证新排列大于原来排列的情况下，使变大的幅度尽可能小。所以可以使用两次排序来确定两个数字的位置，然后进行交换.\n以排列 [4,5,2,6,3,1][4,5,2,6,3,1] 为例：\n我们能找到的符合条件的一对「较小数」与「较大数」的组合为 2 与 3，满足「较小数」尽量靠右，而「较大数」尽可能小。\n当我们完成交换后排列变为 [4,5,3,6,2,1][4,5,3,6,2,1]，此时我们可以重排「较小数」右边的序列，序列变为 [4,5,3,1,2,6][4,5,3,1,2,6]。\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  func nextPermutation(nums []int) { // 先找到一个最小数，然后找到比这个较小数稍微大的较大数 \tn := len(nums) i := n - 2 //找到此时分割左右边的位置  // 也就是较小数尽可能的小 \tfor i \u0026gt;= 0 \u0026amp;\u0026amp; nums[i] \u0026gt;= nums[i+1] { i-- } if i \u0026gt;= 0 { j := n - 1 //找到较小数 \tfor j \u0026gt;= 0 \u0026amp;\u0026amp; nums[i] \u0026gt;= nums[j] { j-- } //交换 \tnums[i], nums[j] = nums[j], nums[i] } //之后反转右边的序列 \treverse(nums[i+1:]) } func reverse(a []int) { for i, n := 0, len(a); i \u0026lt; n/2; i++ { a[i], a[n-1-i] = a[n-1-i], a[i] } }   ","date":"Jun 24","permalink":"https://hearecho.github.io/post/hugo%E6%B7%BB%E5%8A%A0google%E6%94%B6%E5%BD%95/","tags":["Hugo","Google Console","杂记"],"title":"Hugo添加Google收录"},{"categories":["blog"],"contents":"简介  使用hugo搭建个人博客，并结合Github与Travis CI实现自动化集成部署。\n 本地运行 hugo下载（windows） 1  brew install hugo   检查可用之后，使用命令新建一个网站（不用新建文件夹，hugo会自动建立）：\n1 2  hugo new site your-site-name cd your-site-name   主题下载 主题是放到themes目录中，一般从hugo themes中找到想要的主题，下载到themes文件夹中。需要修改配置文件中相关配置，名字为文件夹名称。\n静态资源位置 静态资源位置一般是在网站目录下的static文件夹中\n添加文章 1 2 3  hugo new post/first.md # 该文件会在 content/post/目录下 # 执行编译之后，产生的文件在public目录下   运行 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  hugo server -D # 该条命令是本地测试运行，有可能markdown文件的draft标签为true，在真正编译的时候需要把true改为false # 不然不会显示 hugo # 就是编译命令 编译结果如下 Start building sites … | EN -------------------+----- Pages | 12 Paginator pages | 0 Non-page files | 0 Static files | 1 Processed images | 0 Aliases | 4 Sitemaps | 1 Cleaned | 0 Total in 76 ms   部署  部署我们一般使用两个仓库，一个仓库(blog)用于存放源文件，一个仓库(*.githu.io)用于存放生成的网站静态文件。\n存放源文件的仓库会在Travis中使用。\n 生成github token  前提是仓库已经全部建立，此时我们进入token，生成GITHUB_TOKEN。repo标签内全部选上即可。\n 结合Travis  前提是仓库已经全部建立，此时我们登录tracis ci，使用github进行登录，然后根据提示选择我们需要的仓库。也就是用于存放源文件的仓库。点击仓库右边的setting按钮。进入之后，在下方Environment Variables中添加变量名为GITHUB_TOKEN（这个随意，不过后面取得时候要注意保持一致）。\n 添加.travis.yml文件 这里我直接列举我自己得文件，对应改以下就好。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  language:gogo:- \u0026#34;1.15\u0026#34;# 指定Golang 1.15# Specify which branches to build using a safelist# 分支白名单限制：只有 master 分支的提交才会触发构建branches:only:- masterinstall:# 安装最新的hugo- wget https://github.com/gohugoio/hugo/releases/download/v0.84.0/hugo_0.84.0_Linux-64bit.deb- sudo dpkg -i hugo*.deb# 安装主题- git clone https://github.com/WingLim/hugo-tania.git themes/tania --depth=1script:# 运行hugo命令- hugoafter_script:# 部署- cd ./public- git init- git config user.name \u0026#34;hearecho\u0026#34;- git config user.email \u0026#34;1540302560@qq.com\u0026#34;- git add .- git commit -m \u0026#34;Update Blog By TravisCI With Build $TRAVIS_BUILD_NUMBER\u0026#34;# Github Pages- git push --force --quiet \u0026#34;https://$GITHUB_TOKEN@${GH_REF}\u0026#34; master:masterenv:global:# Github Pages- GH_REF:github.com/hearecho/hearecho.github.iodeploy:provider:pages# 重要，指定这是一份github pages的部署配置skip-cleanup:true# 重要，不能省略local-dir:public# 静态站点文件所在目录# target-branch: master # 要将静态站点文件发布到哪个分支github-token:$GITHUB_TOKEN# 重要，$GITHUB_TOKEN是变量，需要在GitHub上申请、再到配置到Travis# fqdn: # 如果是自定义域名，此处要填keep-history:true# 是否保持target-branch分支的提交记录on:branch:master# 博客源码的分支  提交与检查 到此时，基本上工作已经完成。提交我们此次更改之后，travis会自动进行build，如果出错，应该是步骤问题。\nleetcode 每日一题  请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。\n  解题思路，num与num-1在二进制位进行表示得时候，每次都会在第一个1出现得位置，变得不同，所以我们每次让num与num-1做与运算，直至num\u0026lt;=0\n 1 2 3 4 5 6 7 8  func hammingWeight(num uint32) int { x := 0 for num \u0026gt; 0 { num \u0026amp;= num-1 x++ } return x }   ","date":"Jun 23","permalink":"https://hearecho.github.io/post/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","tags":["Hugo","Travis CI","杂记"],"title":"Hugo搭建个人博客"},{"categories":null,"contents":"","date":"Jun 23","permalink":"https://hearecho.github.io/articles/","tags":null,"title":"全部文章"}]