---
title: "树"
date: 2021-12-10T13:36:27+08:00
draft: false
description: "学习关于树的算法题"
tags:
- 算法
- 面试
- 树
---

## 树

树是一个大类 包括二叉树，二叉搜索树，AVL树，红黑树，N叉树等等。树的算法题大多都可以使用递归进行解决。

### 二叉树

二叉树是指的是节点有小于等于两个出度的树，二叉树算是最基本的树，很多算法题目也是在二叉树的基础上出题。

#### 二叉树的遍历

二叉树的主要有四种遍历方式，前序遍历，中序遍历，后序遍历以及层次遍历。前中后序遍历指的都是根节点在遍历过程中的顺序位置。

##### 前序遍历

前序遍历的顺序就是中前后，先访问根节点，之后再递归访问左子树最后是右子树。

```go
// 递归实现
func preorderRecursive(root *TreeNode, res *[]int) {
	//递归方式
	if root == nil {
		return
	}
	*res = append(*res, root.Val)
	preorderRecursive(root.Left, res)
	preorderRecursive(root.Right, res)
}
// 使用栈来代替系统栈
func preorder(root *TreeNode) []int {
	//使用栈来代替系统栈
	//刚好和后续相反，只不过在加入栈的时候就进行了访问
	stack := make([]*TreeNode, 0)
	res := make([]int, 0)
	for len(stack) != 0 || root != nil {
		//遍历左子树 包括根节点
		for root != nil {
			stack = append(stack, root)
			res = append(res, root.Val)
			root = root.Left
		}
		//弹出
		root = stack[len(stack)-1]
		stack = stack[:len(stack)-1]
		root = root.Right
	}
	return res
}
```

##### 中序遍历

中序遍历则是先访问左边节点之后是根节点，最后才是右子树。

```go
// 递归
func inorderRecursive(root *TreeNode, res *[]int) {
	//递归方式
	if root == nil {
		return
	}
	preorderRecursive(root.Left, res)
	*res = append(*res, root.Val)
	preorderRecursive(root.Right, res)
}
// 使用栈
func inorderTraversal(root *TreeNode) []int {
	res := make([]int, 0)
	stack := make([]*TreeNode, 0)
	//由于右子树可能为空
	for len(stack) != 0 || root != nil {
		//遍历左子树
		for root != nil {
			stack = append(stack, root)
			root = root.Left
		}
		//取出栈顶节点
		root = stack[len(stack)-1]
		res = append(res, root.Val)
		stack = stack[:len(stack)-1]
		root = root.Right
	}
	return res

}
```

##### 后序遍历

后序遍历则是根节点最后访问，访问左子树之后紧跟着访问右子树。

```go
// 递归访问
func postorderRecursive(root *TreeNode, res *[]int) {
	//递归方式
	if root == nil {
		return
	}
	preorderRecursive(root.Left, res)
	preorderRecursive(root.Right, res)
	*res = append(*res, root.Val)
}
// 使用栈
func postorderTraversal(root *TreeNode) []int {
	stack := make([]*TreeNode, 0)
	res := make([]int, 0)
	var prev *TreeNode
	for len(stack) != 0 || root != nil {
		for root != nil {
			stack = append(stack, root)
			root = root.Left
		}
		root = stack[len(stack)-1]
		stack = stack[:len(stack)-1]
		if root.Right == nil || root.Right == prev {
			res = append(res, root.Val)
			prev = root
			root = nil
		} else {
			stack = append(stack, root)
			root = root.Right
		}
	}
	return res
}
```

##### 层次遍历

层次遍历则是使用队列或者是叫做广度优先遍历，一层一层的访问所有的节点，一般层次遍历类型的题目较为简单。

```go
func levelOrder(root *TreeNode) [][]int {
	//层次遍历
	queue := make([]*TreeNode, 0)
	res := make([][]int, 0)
	queue = append(queue, root)
	for len(queue) != 0 && root != nil {
		temp := make([]int, 0)
		size := len(queue)
		for i := 0; i < size; i++ {
			temp = append(temp, queue[i].Val)
			if queue[i].Left != nil {
				queue = append(queue, queue[i].Left)
			}
			if queue[i].Right != nil {
				queue = append(queue, queue[i].Right)
			}
		}
		queue = queue[size:]
		res = append(res, temp)
	}
	return res
}
```

#### 二叉树对称、镜像类型的题目

##### [对称二叉树]([101. 对称二叉树 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/symmetric-tree/))

给定一个二叉树，检查它是否是镜像对称的。

> 对称二叉树说的是整个树的对称，所以需要判断两种情况

```go
func isSymmetric(root *TreeNode) bool {
    //对称是整个树的对称
    if root == nil {
        return true
    }
    return Symmetric(root.Left, root.Right)
}

func Symmetric(left, right *TreeNode) bool {
    if left == nil && right == nil {
        return true
    }
    if left == nil || right {
        return false
    }
    if left.Val != right.Val {
        return false
    }
    return Symmetric(left.Left,right.Right) && Symmetric(left.Right, right.Left)
}
// 迭代的方式
// 迭代的方式就是通过将需要比较的节点暂时存储到队列中，之后再从队列中取出进行比较。
func isSymmetric(root *TreeNode) bool {
    u, v := root, root
    q := []*TreeNode{}
    q = append(q, u)
    q = append(q, v)
    for len(q) > 0 {
        u, v = q[0], q[1]
        q = q[2:]
        // 判断的部分没有进行改变
        if u == nil && v == nil {
            continue
        }
        if u == nil || v == nil {
            return false
        }
        if u.Val != v.Val {
            return false
        }
        q = append(q, u.Left)
        q = append(q, v.Right)

        q = append(q, u.Right)
        q = append(q, v.Left)
    }
    return true
}
```

#### 与二叉树的深度相关的题目

一般情况下与二叉树深度相关的题目也不会太难。

##### [二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

判断二叉树的最大深度即判断每个根节点到叶子节点的最长路径上的节点数，即遇到nil节点返回0，其他加1.

```go
func maxDepth(root *TreeNode) int {
    if root==nil {
        return 0
    }
    return max(maxDepth(root.Left), maxDepth(root.Right))
}
```

##### 平衡二叉树



