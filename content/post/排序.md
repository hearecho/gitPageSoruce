---
title: "排序"
date: 2021-12-30T13:45:44+08:00
draft: false
deacription: "常用的排序算法，选择排序，归并排序，快速排序等等"
tags:
- 排序
---

## 排序

排序算法就是将一组数据按照特定的规则进行排列。排序算法主要从时间复杂度，空间复杂度，稳定性等方面来考虑性能。**稳定性**：稳定性指的是相等的排序元素再经过排序之后相对顺序是否发生了改变。这个主要是防止破环原有的顺序，一般再多次使用不同的`key`来排序元素的时候防止破坏上次排序。

*基数排序、计数排序、插入排序、冒泡排序、归并排序是稳定排序。选择排序、堆排序、快速排序不是稳定排序。*

### 选择排序

选择排序就是一次从未排序的数组中选择最小或者是最大的元素与当前元素进行交换。

#### 稳定性

由于选择排序存在`swap`操作，所以选择排序是一种不稳定排序算法。

#### 时间复杂度和空间复杂度

时间复杂度为$O(n^2)$，没有使用额外的空间。

#### 实现

```go
func SelectSort(nums []int) {
	for i := 0; i < len(nums); i++ {
		min := i
		for j := i; j < len(nums); j++ {
			if nums[min] > nums[j] {
				min = j
			}
		}
		nums[i], nums[min] = nums[min], nums[i]
	}
}
```

### 冒泡排序

冒泡排序相比较于选择排序同样是进行交换，不过冒泡排序是将较小的元素不断的进行上浮。工作原理就是每次比较相邻的两个元素，然后入喉第`i`个元素小于第`i+1`个元素，则将两个元素进行交换，知道某一次遍历过程中没有发生交换则证明排序完成。

#### 稳定性

冒泡排序虽然进行了交换，但是交换是相邻的两个元素进行交换，而相同的元素不会进行交换，所以没有破坏原有的顺序。冒泡排序是一个稳定的排序算法。

#### 时间复杂度和空间复杂度

时间复杂度为$O(n^2)$，完全有序的时候为$O(n)$.没有使用额外的空间。

#### 实现

```go
func BubbleSort(nums []int) {
	flag := true
	for flag {
		flag = false
		for i := 0; i < len(nums)-1; i++ {
			if nums[i] > nums[i+1] {
				flag = true
				nums[i], nums[i+1] = nums[i+1], nums[i]
			}
		}
	}
}
```

### 插入排序

插入排序是将未排序范围内的元素，选择一个然后在插入到已经排序的元素中的正确位置。和选择排序不相同，选择排序是直接将选择的元素加在已经排序元素的最后面，而插入排序需要搜索之后才知道元素的合适位置。

#### 稳定性

插入排序是一种稳定的排序算法。

#### 时间复杂度和空间复杂度

插入排序的最优时间复杂度为 $O(n)$，在数列几乎有序时效率很高。

插入排序的最坏时间复杂度和平均时间复杂度都为 $O(n^2)$，没有使用额外的空间。

#### 实现

```go
func InsertSort(nums []int) {
	for i := 1; i < len(nums); i++ {
		key := nums[i]
		j := i - 1
		for j >= 0 && nums[j] > key {
			// 从后往前遍历，来查找插入位置
			nums[j+1] = nums[j]
			j--
		}
		nums[j+1] = key
	}
}
```

### 快速排序

快排的工作原理就是将数组化作两个部分，然后对每个部分再次进行递归排序，因为在划分的过程已经进行了排序，所以不需要进行合并，此时的数列已经完全有序了。快排在选择哨兵的方法和遍历交换过程都有几种实现方法。

#### 稳定性

快排是一种不稳定的排序算法。

#### 时间复杂度和空间复杂度

快速排序的最优时间复杂度和平均时间复杂度为 $O(nlogn)$，最坏时间复杂度为 $O(n^2)$。

#### 基础实现

基础实现，哨兵选择第一个元素，然后分别使用两个指针从后和从前找到元素进行交换。

```go
func quickSort(nums []int, l, h int) {
	// 第一种 使用双指针从两端进行遍历
	// 哨兵的话使用 nums[l]
	if l >= h {
		return
	}
	i, j := l, h
	watch := nums[l]
	for i < j {
		for i < j && nums[j] >= watch {
			j--
		}
		for i < j && nums[i] <= watch {
			i++
		}
		nums[i], nums[j] = nums[j], nums[i]
	}
	nums[i], nums[l] = nums[l], nums[i]
	quickSort(nums, i+1, h)
	quickSort(nums, l, i-1)
}
```

#### 优化思想

