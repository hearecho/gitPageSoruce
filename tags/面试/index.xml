<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>面试 on Road to Final</title>
    <link>https://hearecho.github.io/tags/%E9%9D%A2%E8%AF%95/</link>
    <description>Recent content in 面试 on Road to Final</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 25 Feb 2022 14:12:22 +0800</lastBuildDate><atom:link href="https://hearecho.github.io/tags/%E9%9D%A2%E8%AF%95/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Go Question</title>
      <link>https://hearecho.github.io/post/go-question/</link>
      <pubDate>Fri, 25 Feb 2022 14:12:22 +0800</pubDate>
      
      <guid>https://hearecho.github.io/post/go-question/</guid>
      <description>Go Questions 1.nil切片和空切片、零切片 nil切片指向的地址为0，而所有创建的空切片的内存地址是存在的，并且是一个固定值。
零切片就是底层数组内部数据全是零变量。说白了就是使用make初始化之后的切片。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  func compareSlice() { var s1 []int s2 := make([]int,0) s4 := make([]int,0) fmt.Printf(&amp;#34;s1 pointer:%+v, s2 pointer:%+v, s4 pointer:%+v, \n&amp;#34;, *(*reflect.SliceHeader)(unsafe.Pointer(&amp;amp;s1)),*(*reflect.SliceHeader)(unsafe.Pointer(&amp;amp;s2)),*(*reflect.SliceHeader)(unsafe.Pointer(&amp;amp;s4))) fmt.Printf(&amp;#34;%v\n&amp;#34;, (*(*reflect.SliceHeader)(unsafe.Pointer(&amp;amp;s1))).Data==(*(*reflect.SliceHeader)(unsafe.Pointer(&amp;amp;s2))).Data) fmt.Printf(&amp;#34;%v\n&amp;#34;, (*(*reflect.SliceHeader)(unsafe.Pointer(&amp;amp;s2))).Data==(*(*reflect.SliceHeader)(unsafe.Pointer(&amp;amp;s4))).Data) } // 结果 /** s1 pointer:{Data:0 Len:0 Cap:0}, s2 pointer:{Data:824633999016 Len:0 Cap:0}, s4 pointer:{Data:824633999016 Len:0 Cap:0}, false true */   2.字符串转换为byte数组，会发生内存拷贝吗？ 严格来说，只要进行了类型的强制转换都会发生内存拷贝。所以说字符串转换为byte数组会发生内存拷贝。go的字符串也为不可变对象，在内存中的实现方式是一个只读的字节数组。字符串要想修改只能先转换为可写的数组，然后在转换为字符串。其数据结构如下：
1 2 3 4  type StringHeader struct { Data uintptr Len int }   用代码展示，可以从结果上看出，不论是从字符串转换为byte数组还是从byte数组转换为字符串，均发生内存拷贝了。</description>
    </item>
    
    <item>
      <title>树</title>
      <link>https://hearecho.github.io/post/%E6%A0%91/</link>
      <pubDate>Fri, 10 Dec 2021 13:36:27 +0800</pubDate>
      
      <guid>https://hearecho.github.io/post/%E6%A0%91/</guid>
      <description>树 树是一个大类 包括二叉树，二叉搜索树，AVL树，红黑树，N叉树等等。树的算法题大多都可以使用递归进行解决。
二叉树 二叉树是指的是节点有小于等于两个出度的树，二叉树算是最基本的树，很多算法题目也是在二叉树的基础上出题。
二叉树的遍历 二叉树的主要有四种遍历方式，前序遍历，中序遍历，后序遍历以及层次遍历。前中后序遍历指的都是根节点在遍历过程中的顺序位置。
前序遍历 前序遍历的顺序就是中前后，先访问根节点，之后再递归访问左子树最后是右子树。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  // 递归实现 func preorderRecursive(root *TreeNode, res *[]int) { //递归方式 	if root == nil { return } *res = append(*res, root.Val) preorderRecursive(root.Left, res) preorderRecursive(root.Right, res) } // 使用栈来代替系统栈 func preorder(root *TreeNode) []int { //使用栈来代替系统栈 	//刚好和后续相反，只不过在加入栈的时候就进行了访问 	stack := make([]*TreeNode, 0) res := make([]int, 0) for len(stack) !</description>
    </item>
    
    <item>
      <title>Redis面试问题</title>
      <link>https://hearecho.github.io/post/redis%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 26 Jun 2021 15:14:50 +0800</pubDate>
      
      <guid>https://hearecho.github.io/post/redis%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/</guid>
      <description>Redis 1.简介 Redis是一种非关系型（NoSQL）内存键值数据库，可以存储键和五种不同类型的值之间的映射。
键的类型只能为字符串，保证不可变性，值的类型只有五种：字符串、列表、集合、哈希表、有序集合。
Redis面试问题的主要出发点：数据类型、跳表、缓存、持久化、数据淘汰策略。
2.数据类型    数据类型 可以存储的值 操作     STRING 字符串、整数或者浮点数 对整个字符串或者字符串的其中一部分执行操作，对整数和浮点数执行自增或者自减操作   LIST 列表 从两端压入或者弹出元素 ，对单个或者多个元素进行修剪， 只保留一个范围内的元素   SET 无序集合 添加、获取、移除单个元素， 检查一个元素是否存在于集合中， 计算交集、并集、差集， 从集合里面随机获取元素   HASH 包含键值对的无序散列表 添加、获取、移除单个键值对， 获取所有键值对，检查某个键是否存在   ZSET 有序集合 添加、获取、删除元素，根据分值范围或者成员来获取元素， 计算一个键的排名    3.数据结构 字典 字典是HASH的底层结构，是一种散列表结构，使用的是拉链法解决哈希冲突。Redis 的字典 dict 中包含两个哈希表 dictht，这是为了方便进行 rehash 操作。在扩容时，将其中一个 dictht 上的键值对 rehash 到另一个 dictht 上面，完成之后释放空间并交换两个 dictht 的角色。有点类似于CopyandWriteList中扩容的操作。rehash 操作不是一次性完成，而是采用渐进方式，这是为了避免一次性执行过多的 rehash 操作给服务器带来过大的负担。
跳表 是有序集合的底层实现之一。跳跃表是基于多指针有序链表实现的，可以看成多个有序链表。在查找时，从上层指针开始查找，找到对应的区间之后再到下一层去查找。</description>
    </item>
    
  </channel>
</rss>
